[{"path":"/2025/02/12/go容易踩的坑/","content":"go语言容易踩的坑切片range 取地址1234567891011func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tmyMap := make(map[int]*int)\tfor i, v := range arr &#123; myMap[i] = &amp;v\t&#125;\tfor _, v := range myMap &#123; fmt.Println(*v)\t&#125;&#125;//输出 3 3 3 1234567891011//正确写法func main() &#123; arr := []int&#123;1, 2, 3&#125; myMap := make(map[int]*int) for i, v := range arr &#123; myMap[i] = &amp;arr[i] &#125; for _, v := range myMap &#123; fmt.Println(*v) &#125;&#125; 死循环？12345678910func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tfor _, v := range arr &#123; arr = append(arr, v)\t&#125;\tfmt.Println(arr)&#125;//输出 [1 2 3 1 2 3]//range 的arr是一个copy 切片传参1234567891011func test(arr []int) &#123;\tarr[0] = 4\tarr = append(arr, 1)&#125;func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\ttest(arr)\tfmt.Println(arr)&#125;//输出 4 2 3 12345678910111213141516171819//切片底层结构type SliceHeader struct&#123; Data uintptr Len int Cap int&#125;//正确写法func test(arr []int) []int &#123;\tarr[0] = 4\tarr = append(arr, 1)\treturn arr&#125;func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tarr = test(arr)\tfmt.Println(arr)&#125; 切片copy12345678910111213141516171819202122232425262728func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := a b[0] = 9 fmt.Println(a)&#125;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := make([]int, 3) b = a[:3] b[0] = 9 b = append(b, 10) fmt.Println(a)&#125;//输出// [9 2 3 4 5]//\t[9 2 3 10 5]func main() &#123;\ta := []int&#123;1, 2, 3, 4, 5&#125;\tb := make([]int, len(a))\tcopy(b, a)\tb[0] = 10\tfmt.Println(a)&#125; json.Unmarshalnull1234567891011func main() &#123;\ts := &quot;null&quot;\tm := make(map[string]interface&#123;&#125;)\tif err := json.Unmarshal([]byte(s), &amp;m); err != nil &#123; fmt.Println(err.Error())\t&#125;\tm[&quot;test&quot;] = 1\tfmt.Println(m)&#125;//panic: assignment to entry in nil map 12345678910111213//正确写法func main() &#123; s := &quot;null&quot; m := make(map[string]interface&#123;&#125;) if err := json.Unmarshal([]byte(s), &amp;m); err != nil &#123; fmt.Println(err.Error()) &#125; if m==nil&#123; return &#125; m[&quot;test&quot;] = 1 fmt.Println(m)&#125; interface{}接收数据12345678910111213141516171819func main() &#123;\tstr := `&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20&#125;`\tvar mp map[string]interface&#123;&#125;\terr := json.Unmarshal([]byte(str), &amp;mp)\tif err != nil &#123; return\t&#125;\tvar age int\tage = mp[&quot;age&quot;].(int)\tfmt.Println(age)&#125;//使用 Golang 解析 json 格式数据时，若以 interface&#123;&#125; 接收数据，则会按照下列规则进行解析：bool for JSON booleansfloat64 for JSON numbersstring for JSON strings[]interface&#123;&#125; for JSON arraysmap[string]interface&#123;&#125; for JSON objectsnil for JSON null deferdefer和return的执行顺序123456789101112131415161718192021222324252627282930313233343536func test() (b int) &#123; defer func() &#123; b += 10 &#125;() return b&#125;func test1() (b int) &#123;\tb = 10\tdefer func() &#123; b += 10\t&#125;()\treturn&#125;func test2() int &#123;\tb := 10\tdefer func() &#123; b += 10\t&#125;()\treturn b&#125;func test3() *int &#123;\tb := 10\tdefer func() &#123; b += 10\t&#125;()\treturn &amp;b&#125;func main() &#123;\tfmt.Println(test1())\tfmt.Println(test2())\tfmt.Println(*test3())&#125;//输出 20 10 20 闭包闭包是通过指针操作母函数中的变量1234567891011121314151617181920212223242526272829303132333435363738394041424344func myPrint(x int) &#123;\tfmt.Println(&quot;defer&quot;, x)&#125;func test1() (x int) &#123;\tdefer myPrint(x)\tx = 10\treturn&#125;func test2() (x int) &#123;\tdefer func() &#123; myPrint(x)\t&#125;()\tx = 10\treturn&#125;func test3() (x int) &#123;\tdefer func(a int) &#123; myPrint(a)\t&#125;(x)\tx = 10\treturn&#125;func main() &#123;\tvar res int\tfmt.Println(&quot;test1 &quot;)\tres = test1()\tfmt.Println(&quot;main&quot;, res)\tfmt.Println(&quot;test2&quot;)\tres = test2()\tfmt.Println(&quot;main&quot;, res)\tfmt.Println(&quot;test3&quot;)\tres = test3()\tfmt.Println(&quot;main&quot;, res)&#125;//输出test1 defer 0main 10test2defer 10main 10test3defer 0main 10 注意变量的作用域1234567891011121314151617181920212223func Foo() (err error) &#123; if err := Bar(); err != nil &#123; return &#125; return&#125;//正确写法func Foo() (err error) &#123; if err := Bar(); err != nil &#123; return err &#125; return&#125;//或func Foo() (err error) &#123; if er := Bar(); er != nil &#123; err = er return &#125; return&#125; map初始化的时候尽量指定map容量1m := make(map[int],100) range 便利map时，注意map的无序性1234567891011121314151617181920212223242526func main() &#123;\tmax := 10\tmp := make(map[int]int, max)\tfor i := 0; i &lt; max; i++ &#123; mp[i] = i + 1\t&#125;\tfor k, v := range mp &#123; fmt.Println(k, v)\t&#125;&#125;func main() &#123;\tmax := 10\tmp := make(map[int]int, max)\tarr := make([]int, 0, max)\tfor i := 0; i &lt; max; i++ &#123; mp[i] = i + 1 arr = append(arr, i)\t&#125;\tfor _, v := range arr &#123; fmt.Println(v, mp[v])\t&#125;&#125; nil map写入会panic12345678910111213func main() &#123;\tvar mp map[int]struct&#123;&#125;\tmp[1] = struct&#123;&#125;&#123;&#125;\tfmt.Println(mp)&#125;//panic: assignment to entry in nil mapfunc main() &#123;\tmp := make(map[int]struct&#123;&#125;)\tmp[1] = struct&#123;&#125;&#123;&#125;\tfmt.Println(mp)&#125; map不是并发安全的12345678910111213141516171819202122232425262728293031323334353637383940func main() &#123;\tmax := 100\tmp := make(map[int]int, max)\twg := sync.WaitGroup&#123;&#125;\twg.Add(max)\tfor i := 0; i &lt; max; i++ &#123; tmp := i go func() &#123; defer func() &#123; wg.Done() &#125;() mp[tmp] = tmp &#125;()\t&#125;\twg.Wait()\tfmt.Println(mp)&#125;//fatal error: concurrent map writesfunc main() &#123;\tmax := 100\tvar mp sync.Map\twg := sync.WaitGroup&#123;&#125;\twg.Add(max)\tfor i := 0; i &lt; max; i++ &#123; tmp := i go func() &#123; defer func() &#123; wg.Done() &#125;() mp.Store(tmp, tmp) &#125;()\t&#125;\twg.Wait()\tmp.Range(func(k, v interface&#123;&#125;) bool &#123; fmt.Println(k, v) return true\t&#125;)&#125;"},{"path":"/2025/02/11/playwright/","content":"Playwright 安装1Looks like Playwright was just installed or updated. ║ ║ Please run the following command to download new browsers: ║ ║ ║ ║ playwright install ║ ║ ║ ║ &lt;3 Playwright Team 看到这个提示，说明你刚刚安装或更新了 Playwright，但还需要下载 Playwright 所需的浏览器（如 Chromium、Firefox、WebKit 等）。以下是具体操作步骤： 1 直接运行安装命令在终端（命令行）中执行以下命令，自动下载浏览器： 1playwright install 这会自动下载 Playwright 支持的浏览器（默认包括 Chromium、Firefox 和 WebKit）。 2 可选：指定浏览器安装如果只需要安装特定浏览器，可以指定浏览器名称： 123playwright install chromium # 仅安装 Chromiumplaywright install firefox # 仅安装 Firefoxplaywright install webkit # 仅安装 WebKit 3 验证是否成功安装完成后，运行以下命令测试 Playwright 是否正常工作： 1playwright test 如果看到浏览器自动启动并运行测试，说明一切就绪。 4 常见问题解决 权限问题（Linux&#x2F;macOS）： 如果提示权限不足，尝试在命令前加 sudo： 1sudo playwright install 网络问题： 如果下载速度慢或失败（尤其在国内），可以尝试： 使用国内镜像源（需配置环境变量）： 1PLAYWRIGHT_DOWNLOAD_HOST=https://npmmirror.com/mirrors/playwright playwright install 通过 npm 配置镜像（如果通过 npm 安装 Playwright）如果你通过 npm 安装 Playwright，可以配置 npm 镜像源： 1234# 设置 npm 镜像npm config set registry https://registry.npmmirror.com# 安装 Playwright 并自动使用镜像npm install playwright 找不到命令： 如果提示 playwright: command not found，可能是安装路径未添加到系统环境变量。尝试： 1python -m playwright install # 通过 Python 模块直接调用 为什么需要这一步？Playwright 是一个浏览器自动化工具，它依赖真实的浏览器引擎来运行测试。首次安装时，需要单独下载这些浏览器二进制文件，因此官方提示你执行 playwright install。 完成后，你就可以正常使用 Playwright 进行自动化测试了！ 🚀"},{"path":"/2025/02/09/Go语言十个技巧/","content":"GO语言最有价值的十个技巧GO语言（又称Golang）以其简洁、高效和并发支持而闻名。作为一名GO开发者，掌握一些实用的技巧可以显著提升代码质量和开发效率。本文将分享十个GO语言中最有价值的技巧，并通过代码示例帮助你快速上手。 1. 使用defer简化资源管理defer是GO语言中用于延迟执行的关键字，常用于资源释放（如关闭文件、解锁互斥锁等）。它可以确保资源在函数结束时被正确释放，避免资源泄漏。 12345678910111213func readFile(filename string) (string, error) &#123; file, err := os.Open(filename) if err != nil &#123; return &quot;&quot;, err &#125; defer file.Close() // 确保文件在函数结束时关闭 content, err := io.ReadAll(file) if err != nil &#123; return &quot;&quot;, err &#125; return string(content), nil&#125; 2. 利用goroutine实现并发GO语言的goroutine是实现并发的核心工具。它比线程更轻量，启动速度快，适合处理高并发任务。 123456789101112func printNumbers() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125;&#125;func main() &#123; go printNumbers() // 启动一个goroutine go printNumbers() // 启动另一个goroutine time.Sleep(3 * time.Second) // 等待goroutine执行完毕&#125; 3. 使用channel进行通信channel是GO语言中用于goroutine之间通信的工具。它可以安全地传递数据，避免竞态条件。 123456789101112131415161718192021222324func worker(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for job := range jobs &#123; fmt.Printf(&quot;Worker %d processing job %d &quot;, id, job) results &lt;- job * 2 &#125;&#125;func main() &#123; jobs := make(chan int, 10) results := make(chan int, 10) for w := 1; w &lt;= 3; w++ &#123; go worker(w, jobs, results) &#125; for j := 1; j &lt;= 5; j++ &#123; jobs &lt;- j &#125; close(jobs) for a := 1; a &lt;= 5; a++ &#123; fmt.Println(&quot;Result:&quot;, &lt;-results) &#125;&#125; 4. 使用sync.WaitGroup等待多个goroutine完成sync.WaitGroup用于等待一组goroutine完成任务，非常适合需要同步的场景。 12345678910111213141516func worker(id int, wg *sync.WaitGroup) &#123; defer wg.Done() // 任务完成后通知WaitGroup fmt.Printf(&quot;Worker %d starting &quot;, id) time.Sleep(time.Second) fmt.Printf(&quot;Worker %d done &quot;, id)&#125;func main() &#123; var wg sync.WaitGroup for i := 1; i &lt;= 3; i++ &#123; wg.Add(1) // 增加WaitGroup的计数器 go worker(i, &amp;wg) &#125; wg.Wait() // 等待所有goroutine完成 fmt.Println(&quot;All workers done&quot;)&#125; 5. 使用interface实现多态GO语言通过interface实现多态，允许不同类型的对象实现相同的接口。 1234567891011121314151617181920type Animal interface &#123; Speak() string&#125;type Dog struct&#123;&#125;func (d Dog) Speak() string &#123; return &quot;Woof!&quot;&#125;type Cat struct&#123;&#125;func (c Cat) Speak() string &#123; return &quot;Meow!&quot;&#125;func main() &#123; animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125; for _, animal := range animals &#123; fmt.Println(animal.Speak()) &#125;&#125; 6. 使用context管理goroutine生命周期context用于控制goroutine的生命周期，特别是在需要取消任务或设置超时的场景中非常有用。 1234567891011121314151617181920212223func worker(ctx context.Context, wg *sync.WaitGroup) &#123; defer wg.Done() for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;Worker canceled&quot;) return default: fmt.Println(&quot;Working...&quot;) time.Sleep(500 * time.Millisecond) &#125; &#125;&#125;func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() var wg sync.WaitGroup wg.Add(1) go worker(ctx, &amp;wg) wg.Wait()&#125; 7. 使用struct标签实现JSON序列化GO语言支持通过struct标签将结构体字段映射为JSON字段，方便数据的序列化和反序列化。 12345678910type User struct &#123; Name string `json:&quot;name&quot;` Email string `json:&quot;email&quot;`&#125;func main() &#123; user := User&#123;Name: &quot;Alice&quot;, Email: &quot;alice@example.com&quot;&#125; jsonData, _ := json.Marshal(user) fmt.Println(string(jsonData)) // 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;email&quot;:&quot;alice@example.com&quot;&#125;&#125; 8. 使用errors包创建自定义错误GO语言的errors包允许创建自定义错误，便于错误处理和调试。 1234567891011121314151617import &quot;errors&quot;func divide(a, b int) (int, error) &#123; if b == 0 &#123; return 0, errors.New(&quot;division by zero&quot;) &#125; return a / b, nil&#125;func main() &#123; result, err := divide(10, 0) if err != nil &#123; fmt.Println(&quot;Error:&quot;, err) &#125; else &#123; fmt.Println(&quot;Result:&quot;, result) &#125;&#125; 9. 使用go mod管理依赖go mod是GO语言的官方依赖管理工具，可以轻松管理项目的依赖关系。 12345678# 初始化模块go mod init myproject# 添加依赖go get github.com/example/package# 清理未使用的依赖go mod tidy 10. 使用testing包编写单元测试GO语言内置了testing包，支持编写单元测试，确保代码质量。 123456789101112import &quot;testing&quot;func Add(a, b int) int &#123; return a + b&#125;func TestAdd(t *testing.T) &#123; result := Add(2, 3) if result != 5 &#123; t.Errorf(&quot;Expected 5, got %d&quot;, result) &#125;&#125; 运行测试： 1go test 以上是GO语言中最有价值的十个技巧，涵盖了资源管理、并发编程、错误处理等多个方面。希望这些技巧能帮助你写出更高效、更健壮的GO代码！如果你有其他问题，欢迎在评论区留言讨论。"},{"path":"/2025/02/08/tts/","content":"1. 安装ttshttps://github.com/idiap/coqui-ai-TTS"},{"path":"/2025/02/06/自我介绍/","content":"自我介绍 ✨我是 董洪伟，一名来自 北京 的 软件工程师。我热爱编程和技术分享，专注于 Web 开发 和 人工智能 领域。 @keyframes glow { 0% { text-shadow: 0 0 5px #33FF57, 0 0 10px #33FF57; } 100% { text-shadow: 0 0 20px #33FF57, 0 0 30px #33FF57; } } 🚀 我的经历 教育背景：毕业于 南京理工大学，主修 智能科学与技术。 工作经历：目前在 百度 担任担任资深开发工程师。 技术栈：熟练掌握 Golang、Python。 🌟 我的兴趣 喜欢研究 前沿技术，尤其是 AIGC 和 工程架构。 业余时间会写一些技术博客，分享我的学习和实践经验。 热爱 阅读年均阅读量 50+。 📬 联系我如果你对我的博客内容感兴趣，或者有任何问题，欢迎通过以下方式联系我： 邮箱：derekdongsir@163.com GitHub: https://github.com/DerekDongSir 个人网站：https://blog.derekdong.com/ 感谢你的阅读，期待与你交流！🎉"},{"path":"/2025/01/26/评论系统/","content":"https://zhuanlan.zhihu.com/p/691921194https://giscus.app/zh-CN"},{"title":"Sug","path":"/2025/01/26/sug/","content":"生产环境的sug功能如何实现"},{"title":"Hello World","path":"/2025/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.addEventListener('DOMContentLoaded', function() { const heatmapChartDom = document.getElementById('heatmapChart-0'); if (heatmapChartDom) { const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; const backgroundColor = isDarkMode ? '#333' : 'transparent'; let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light'); const cellSize = [16, 16]; const groupedData = {\"2025\":[[\"2025-01-26\",3]]}; const years = Object.keys(groupedData).reverse(); const initYear = '2025' || years[0]; // Define color themes const themes = { oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'], forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'], sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'], earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'], pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'], golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'], berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'], charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'], }; // Function to get a random theme function getRandomTheme() { const themeKeys = Object.keys(themes); const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)]; return themes[randomKey]; } // Use the specified theme or default to 'random' const colors = themes['random'.toLowerCase()] || getRandomTheme(); const chartOptions = { backgroundColor: backgroundColor, tooltip: { position: 'top', confine: true, formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`, }, calendar: { top: '13%', left: '2%', right: '8%', range: initYear, cellSize: cellSize, splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor }, dayLabel: { show: false }, monthLabel: { show: true }, yearLabel: { show: false }, }, visualMap: { show: true, right: '8%', bottom: '5%', type: 'piecewise', orient: 'horizontal', text: ['More', 'Less'], min: 0, max: Math.max(...groupedData[initYear].map(item => item[1])), inRange: { color: colors }, }, legend: { type: 'scroll', icon: 'none', data: years, orient: 'vertical', top: '5%', right: 'right', itemWidth: 20, itemHeight: 20, itemGap: 10, pageIconSize: 10, pageTextStyle: { fontSize: 14 }, selectedMode: 'single', }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== initYear, })), }; heatmapChart.setOption(chartOptions); heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Function to handle legend selection changes const handleLegendSelectChanged = function(params) { const selectedYear = Object.keys(params.selected).find(key => params.selected[key]); if (selectedYear && groupedData[selectedYear]) { heatmapChart.setOption({ calendar: { range: selectedYear }, visualMap: { max: Math.max(...groupedData[selectedYear].map(item => item[1])), }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== selectedYear, })), }); } }; const handleClick = function(params) { if (params.componentType === 'series') { const [year, month] = params.value[0].split('-'); window.location.href = '/archives/' + year + '/' + month; } }; heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); // Listen for theme changes window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => { heatmapChart.dispose(); heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light'); const newBackgroundColor = event.matches ? '#333' : 'transparent'; chartOptions.backgroundColor = newBackgroundColor; chartOptions.calendar.itemStyle.color = newBackgroundColor; heatmapChart.setOption(chartOptions); // Re-select the initial year heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Reattach the event listeners heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); }); } }); Powered by hexo-stats-echarts"},{"path":"/prompt.html","content":"你是一名GO技术专家，擅长使用GO语言，同时，你是一名技术博主，擅长将技术知识以通俗易懂的方式进行讲解。 现在，你正在写一篇关于GO语言的文章，文章的标题是：《GO语言最有价值的十个技巧》。 请根据以下要求，撰写一篇关于GO语言编程的文章： 文章需要包含10个GO语言的技巧。 文章需要使用通俗易懂的语言，让读者容易理解。 文章需要包含代码示例，让读者可以实际操作。 文章以markdown格式编写，并使用代码高亮。"}]