[{"path":"/2025/02/06/è‡ªæˆ‘ä»‹ç»/","content":"è‡ªæˆ‘ä»‹ç» âœ¨æˆ‘æ˜¯ è‘£æ´ªä¼Ÿï¼Œä¸€åæ¥è‡ª åŒ—äº¬ çš„ è½¯ä»¶å·¥ç¨‹å¸ˆã€‚æˆ‘çƒ­çˆ±ç¼–ç¨‹å’ŒæŠ€æœ¯åˆ†äº«ï¼Œä¸“æ³¨äºŽ Web å¼€å‘ å’Œ äººå·¥æ™ºèƒ½ é¢†åŸŸã€‚ @keyframes glow { 0% { text-shadow: 0 0 5px #33FF57, 0 0 10px #33FF57; } 100% { text-shadow: 0 0 20px #33FF57, 0 0 30px #33FF57; } } ðŸš€ æˆ‘çš„ç»åŽ† æ•™è‚²èƒŒæ™¯ï¼šæ¯•ä¸šäºŽ å—äº¬ç†å·¥å¤§å­¦ï¼Œä¸»ä¿® æ™ºèƒ½ç§‘å­¦ä¸ŽæŠ€æœ¯ã€‚ å·¥ä½œç»åŽ†ï¼šç›®å‰åœ¨ ç™¾åº¦ æ‹…ä»»æ‹…ä»»èµ„æ·±å¼€å‘å·¥ç¨‹å¸ˆã€‚ æŠ€æœ¯æ ˆï¼šç†Ÿç»ƒæŽŒæ¡ Golangã€Pythonã€‚ ðŸŒŸ æˆ‘çš„å…´è¶£ å–œæ¬¢ç ”ç©¶ å‰æ²¿æŠ€æœ¯ï¼Œå°¤å…¶æ˜¯ AIGC å’Œ å·¥ç¨‹æž¶æž„ã€‚ ä¸šä½™æ—¶é—´ä¼šå†™ä¸€äº›æŠ€æœ¯åšå®¢ï¼Œåˆ†äº«æˆ‘çš„å­¦ä¹ å’Œå®žè·µç»éªŒã€‚ çƒ­çˆ± é˜…è¯»å¹´å‡é˜…è¯»é‡ 50+ã€‚ ðŸ“¬ è”ç³»æˆ‘å¦‚æžœä½ å¯¹æˆ‘çš„åšå®¢å†…å®¹æ„Ÿå…´è¶£ï¼Œæˆ–è€…æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žé€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ï¼š é‚®ç®±ï¼šderekdongsir@163.com GitHub: https://github.com/DerekDongSir ä¸ªäººç½‘ç«™ï¼šhttps://blog.derekdong.com/ æ„Ÿè°¢ä½ çš„é˜…è¯»ï¼ŒæœŸå¾…ä¸Žä½ äº¤æµï¼ðŸŽ‰"},{"path":"/2025/01/26/è¯„è®ºç³»ç»Ÿ/","content":"https://zhuanlan.zhihu.com/p/691921194https://giscus.app/zh-CN"},{"title":"Sug","path":"/2025/01/26/sug/","content":"ç”Ÿäº§çŽ¯å¢ƒçš„sugåŠŸèƒ½å¦‚ä½•å®žçŽ°"},{"title":"Hello World","path":"/2025/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.addEventListener('DOMContentLoaded', function() { const heatmapChartDom = document.getElementById('heatmapChart-0'); if (heatmapChartDom) { const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; const backgroundColor = isDarkMode ? '#333' : 'transparent'; let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light'); const cellSize = [16, 16]; const groupedData = {\"2025\":[[\"2025-01-26\",3]]}; const years = Object.keys(groupedData).reverse(); const initYear = '2025' || years[0]; // Define color themes const themes = { oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'], forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'], sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'], earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'], pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'], golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'], berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'], charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'], }; // Function to get a random theme function getRandomTheme() { const themeKeys = Object.keys(themes); const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)]; return themes[randomKey]; } // Use the specified theme or default to 'random' const colors = themes['random'.toLowerCase()] || getRandomTheme(); const chartOptions = { backgroundColor: backgroundColor, tooltip: { position: 'top', confine: true, formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`, }, calendar: { top: '13%', left: '2%', right: '8%', range: initYear, cellSize: cellSize, splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor }, dayLabel: { show: false }, monthLabel: { show: true }, yearLabel: { show: false }, }, visualMap: { show: true, right: '8%', bottom: '5%', type: 'piecewise', orient: 'horizontal', text: ['More', 'Less'], min: 0, max: Math.max(...groupedData[initYear].map(item => item[1])), inRange: { color: colors }, }, legend: { type: 'scroll', icon: 'none', data: years, orient: 'vertical', top: '5%', right: 'right', itemWidth: 20, itemHeight: 20, itemGap: 10, pageIconSize: 10, pageTextStyle: { fontSize: 14 }, selectedMode: 'single', }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== initYear, })), }; heatmapChart.setOption(chartOptions); heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Function to handle legend selection changes const handleLegendSelectChanged = function(params) { const selectedYear = Object.keys(params.selected).find(key => params.selected[key]); if (selectedYear && groupedData[selectedYear]) { heatmapChart.setOption({ calendar: { range: selectedYear }, visualMap: { max: Math.max(...groupedData[selectedYear].map(item => item[1])), }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== selectedYear, })), }); } }; const handleClick = function(params) { if (params.componentType === 'series') { const [year, month] = params.value[0].split('-'); window.location.href = '/archives/' + year + '/' + month; } }; heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); // Listen for theme changes window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => { heatmapChart.dispose(); heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light'); const newBackgroundColor = event.matches ? '#333' : 'transparent'; chartOptions.backgroundColor = newBackgroundColor; chartOptions.calendar.itemStyle.color = newBackgroundColor; heatmapChart.setOption(chartOptions); // Re-select the initial year heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Reattach the event listeners heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); }); } }); Powered by hexo-stats-echarts"}]