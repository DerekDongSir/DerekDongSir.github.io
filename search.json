[{"path":"/2025/02/13/redis与数据库的双写一致性方案/","content":"Redis与数据库的双写一致性是分布式系统中常见的挑战，核心目标是在缓存（Redis）和数据库之间维持数据的一致性。以下是常见的解决方案及其实现逻辑： 1. 缓存更新策略1.1 Cache-Aside（旁路缓存） 核心逻辑：由应用层管理缓存和数据库的读写。 读操作： 先读缓存，命中则返回； 未命中则读数据库，回填缓存。 写操作： 先更新数据库； 再删除缓存（而非更新，避免并发写导致脏数据）。 优点：简单、通用，适用于读多写少场景。 缺点： 短暂不一致：若数据库更新后、缓存删除前有读请求，会读到旧数据。 需处理缓存删除失败（需重试或异步补偿）。 1.2 Write-Through（直写） 核心逻辑：所有写操作同时更新数据库和缓存。 写操作： 先更新缓存； 同步更新数据库。 优点：强一致性。 缺点： 写入性能低（需同时写缓存和数据库）； 不适用于写多场景。 2. 双删策略延迟双删 核心逻辑： 先删除缓存； 更新数据库； 延迟一段时间后再次删除缓存（确保主从同步完成后的旧数据清理）。 适用场景：数据库主从架构，存在同步延迟。 关键参数：延迟时间需大于主从同步时间（如500ms）。 缺点：依赖延迟时间的准确性。 3. 异步补偿3.1 基于消息队列 核心逻辑： 更新数据库； 发送消息到MQ，异步删除缓存； 消费端重试失败任务。 优点：解耦、保证最终一致性。 缺点：系统复杂度增加，需维护MQ。 3.2 基于数据库Binlog（如Canal） 核心逻辑： 数据库更新后，通过Binlog（如MySQL）捕获变更； 通过中间件（如Canal）解析Binlog； 异步更新或删除缓存。 优点：无侵入性，保证最终一致性。 缺点：依赖数据库日志同步机制，延迟可能较高。 4. 强一致性方案4.1 分布式锁 核心逻辑： 写操作前获取分布式锁； 更新数据库后删除缓存； 读操作若缓存未命中，需先获取锁再查数据库。 优点：强一致性。 缺点：性能低，复杂度高。 4.2 版本号&#x2F;时间戳 核心逻辑： 数据写入时附带版本号； 更新时校验版本号，防止旧数据覆盖； 缓存中存储版本号，读请求需校验。 适用场景：对一致性要求极高的场景（如库存扣减）。 缺点：实现复杂，需维护版本号。 5. 方案对比与选择 方案 一致性级别 性能 复杂度 适用场景 Cache-Aside 最终一致 高 低 读多写少 延迟双删 最终一致 中 中 主从同步延迟场景 异步补偿（MQ&#x2F;Binlog） 最终一致 中 高 高并发、最终一致场景 分布式锁 强一致 低 高 对一致性要求极高的场景 6. 最佳实践 优先最终一致性：大多数场景不需要强一致，可通过异步补偿或延迟双删实现。 监控与告警：监控缓存与数据库不一致的时长，设置阈值告警。 兜底策略： 缓存设置合理的TTL，避免长期不一致； 关键数据（如库存）采用强一致性方案。 总结选择方案需权衡业务场景（一致性要求、读写比例）、系统复杂度及性能。例如： 电商商品详情页：Cache-Aside + 异步补偿； 金融交易系统：分布式锁 + 版本号。"},{"path":"/2025/02/12/go容易踩的坑/","content":"go语言容易踩的坑切片range 取地址1234567891011func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tmyMap := make(map[int]*int)\tfor i, v := range arr &#123; myMap[i] = &amp;v\t&#125;\tfor _, v := range myMap &#123; fmt.Println(*v)\t&#125;&#125;//输出 3 3 3 1234567891011//正确写法func main() &#123; arr := []int&#123;1, 2, 3&#125; myMap := make(map[int]*int) for i, v := range arr &#123; myMap[i] = &amp;arr[i] &#125; for _, v := range myMap &#123; fmt.Println(*v) &#125;&#125; 死循环？12345678910func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tfor _, v := range arr &#123; arr = append(arr, v)\t&#125;\tfmt.Println(arr)&#125;//输出 [1 2 3 1 2 3]//range 的arr是一个copy 切片传参1234567891011func test(arr []int) &#123;\tarr[0] = 4\tarr = append(arr, 1)&#125;func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\ttest(arr)\tfmt.Println(arr)&#125;//输出 4 2 3 12345678910111213141516171819//切片底层结构type SliceHeader struct&#123; Data uintptr Len int Cap int&#125;//正确写法func test(arr []int) []int &#123;\tarr[0] = 4\tarr = append(arr, 1)\treturn arr&#125;func main() &#123;\tarr := []int&#123;1, 2, 3&#125;\tarr = test(arr)\tfmt.Println(arr)&#125; 切片copy12345678910111213141516171819202122232425262728func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := a b[0] = 9 fmt.Println(a)&#125;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := make([]int, 3) b = a[:3] b[0] = 9 b = append(b, 10) fmt.Println(a)&#125;//输出// [9 2 3 4 5]//\t[9 2 3 10 5]func main() &#123;\ta := []int&#123;1, 2, 3, 4, 5&#125;\tb := make([]int, len(a))\tcopy(b, a)\tb[0] = 10\tfmt.Println(a)&#125; json.Unmarshalnull1234567891011func main() &#123;\ts := &quot;null&quot;\tm := make(map[string]interface&#123;&#125;)\tif err := json.Unmarshal([]byte(s), &amp;m); err != nil &#123; fmt.Println(err.Error())\t&#125;\tm[&quot;test&quot;] = 1\tfmt.Println(m)&#125;//panic: assignment to entry in nil map 12345678910111213//正确写法func main() &#123; s := &quot;null&quot; m := make(map[string]interface&#123;&#125;) if err := json.Unmarshal([]byte(s), &amp;m); err != nil &#123; fmt.Println(err.Error()) &#125; if m==nil&#123; return &#125; m[&quot;test&quot;] = 1 fmt.Println(m)&#125; interface{}接收数据12345678910111213141516171819func main() &#123;\tstr := `&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20&#125;`\tvar mp map[string]interface&#123;&#125;\terr := json.Unmarshal([]byte(str), &amp;mp)\tif err != nil &#123; return\t&#125;\tvar age int\tage = mp[&quot;age&quot;].(int)\tfmt.Println(age)&#125;//使用 Golang 解析 json 格式数据时，若以 interface&#123;&#125; 接收数据，则会按照下列规则进行解析：bool for JSON booleansfloat64 for JSON numbersstring for JSON strings[]interface&#123;&#125; for JSON arraysmap[string]interface&#123;&#125; for JSON objectsnil for JSON null deferdefer和return的执行顺序123456789101112131415161718192021222324252627282930313233343536func test() (b int) &#123; defer func() &#123; b += 10 &#125;() return b&#125;func test1() (b int) &#123;\tb = 10\tdefer func() &#123; b += 10\t&#125;()\treturn&#125;func test2() int &#123;\tb := 10\tdefer func() &#123; b += 10\t&#125;()\treturn b&#125;func test3() *int &#123;\tb := 10\tdefer func() &#123; b += 10\t&#125;()\treturn &amp;b&#125;func main() &#123;\tfmt.Println(test1())\tfmt.Println(test2())\tfmt.Println(*test3())&#125;//输出 20 10 20 闭包闭包是通过指针操作母函数中的变量1234567891011121314151617181920212223242526272829303132333435363738394041424344func myPrint(x int) &#123;\tfmt.Println(&quot;defer&quot;, x)&#125;func test1() (x int) &#123;\tdefer myPrint(x)\tx = 10\treturn&#125;func test2() (x int) &#123;\tdefer func() &#123; myPrint(x)\t&#125;()\tx = 10\treturn&#125;func test3() (x int) &#123;\tdefer func(a int) &#123; myPrint(a)\t&#125;(x)\tx = 10\treturn&#125;func main() &#123;\tvar res int\tfmt.Println(&quot;test1 &quot;)\tres = test1()\tfmt.Println(&quot;main&quot;, res)\tfmt.Println(&quot;test2&quot;)\tres = test2()\tfmt.Println(&quot;main&quot;, res)\tfmt.Println(&quot;test3&quot;)\tres = test3()\tfmt.Println(&quot;main&quot;, res)&#125;//输出test1 defer 0main 10test2defer 10main 10test3defer 0main 10 注意变量的作用域1234567891011121314151617181920212223func Foo() (err error) &#123; if err := Bar(); err != nil &#123; return &#125; return&#125;//正确写法func Foo() (err error) &#123; if err := Bar(); err != nil &#123; return err &#125; return&#125;//或func Foo() (err error) &#123; if er := Bar(); er != nil &#123; err = er return &#125; return&#125; map初始化的时候尽量指定map容量1m := make(map[int],100) range 便利map时，注意map的无序性1234567891011121314151617181920212223242526func main() &#123;\tmax := 10\tmp := make(map[int]int, max)\tfor i := 0; i &lt; max; i++ &#123; mp[i] = i + 1\t&#125;\tfor k, v := range mp &#123; fmt.Println(k, v)\t&#125;&#125;func main() &#123;\tmax := 10\tmp := make(map[int]int, max)\tarr := make([]int, 0, max)\tfor i := 0; i &lt; max; i++ &#123; mp[i] = i + 1 arr = append(arr, i)\t&#125;\tfor _, v := range arr &#123; fmt.Println(v, mp[v])\t&#125;&#125; nil map写入会panic12345678910111213func main() &#123;\tvar mp map[int]struct&#123;&#125;\tmp[1] = struct&#123;&#125;&#123;&#125;\tfmt.Println(mp)&#125;//panic: assignment to entry in nil mapfunc main() &#123;\tmp := make(map[int]struct&#123;&#125;)\tmp[1] = struct&#123;&#125;&#123;&#125;\tfmt.Println(mp)&#125; map不是并发安全的12345678910111213141516171819202122232425262728293031323334353637383940func main() &#123;\tmax := 100\tmp := make(map[int]int, max)\twg := sync.WaitGroup&#123;&#125;\twg.Add(max)\tfor i := 0; i &lt; max; i++ &#123; tmp := i go func() &#123; defer func() &#123; wg.Done() &#125;() mp[tmp] = tmp &#125;()\t&#125;\twg.Wait()\tfmt.Println(mp)&#125;//fatal error: concurrent map writesfunc main() &#123;\tmax := 100\tvar mp sync.Map\twg := sync.WaitGroup&#123;&#125;\twg.Add(max)\tfor i := 0; i &lt; max; i++ &#123; tmp := i go func() &#123; defer func() &#123; wg.Done() &#125;() mp.Store(tmp, tmp) &#125;()\t&#125;\twg.Wait()\tmp.Range(func(k, v interface&#123;&#125;) bool &#123; fmt.Println(k, v) return true\t&#125;)&#125;"},{"path":"/2025/02/11/playwright/","content":"Playwright 安装1Looks like Playwright was just installed or updated. ║ ║ Please run the following command to download new browsers: ║ ║ ║ ║ playwright install ║ ║ ║ ║ &lt;3 Playwright Team 看到这个提示，说明你刚刚安装或更新了 Playwright，但还需要下载 Playwright 所需的浏览器（如 Chromium、Firefox、WebKit 等）。以下是具体操作步骤： 1 直接运行安装命令在终端（命令行）中执行以下命令，自动下载浏览器： 1playwright install 这会自动下载 Playwright 支持的浏览器（默认包括 Chromium、Firefox 和 WebKit）。 2 可选：指定浏览器安装如果只需要安装特定浏览器，可以指定浏览器名称： 123playwright install chromium # 仅安装 Chromiumplaywright install firefox # 仅安装 Firefoxplaywright install webkit # 仅安装 WebKit 3 验证是否成功安装完成后，运行以下命令测试 Playwright 是否正常工作： 1playwright test 如果看到浏览器自动启动并运行测试，说明一切就绪。 4 常见问题解决 权限问题（Linux&#x2F;macOS）： 如果提示权限不足，尝试在命令前加 sudo： 1sudo playwright install 网络问题： 如果下载速度慢或失败（尤其在国内），可以尝试： 使用国内镜像源（需配置环境变量）： 1PLAYWRIGHT_DOWNLOAD_HOST=https://npmmirror.com/mirrors/playwright playwright install 通过 npm 配置镜像（如果通过 npm 安装 Playwright）如果你通过 npm 安装 Playwright，可以配置 npm 镜像源： 1234# 设置 npm 镜像npm config set registry https://registry.npmmirror.com# 安装 Playwright 并自动使用镜像npm install playwright 找不到命令： 如果提示 playwright: command not found，可能是安装路径未添加到系统环境变量。尝试： 1python -m playwright install # 通过 Python 模块直接调用 为什么需要这一步？Playwright 是一个浏览器自动化工具，它依赖真实的浏览器引擎来运行测试。首次安装时，需要单独下载这些浏览器二进制文件，因此官方提示你执行 playwright install。 完成后，你就可以正常使用 Playwright 进行自动化测试了！ 🚀"},{"path":"/2025/02/09/Go语言十个技巧/","content":"GO语言最有价值的十个技巧GO语言（又称Golang）以其简洁、高效和并发支持而闻名。作为一名GO开发者，掌握一些实用的技巧可以显著提升代码质量和开发效率。本文将分享十个GO语言中最有价值的技巧，并通过代码示例帮助你快速上手。 1. 使用defer简化资源管理defer是GO语言中用于延迟执行的关键字，常用于资源释放（如关闭文件、解锁互斥锁等）。它可以确保资源在函数结束时被正确释放，避免资源泄漏。 12345678910111213func readFile(filename string) (string, error) &#123; file, err := os.Open(filename) if err != nil &#123; return &quot;&quot;, err &#125; defer file.Close() // 确保文件在函数结束时关闭 content, err := io.ReadAll(file) if err != nil &#123; return &quot;&quot;, err &#125; return string(content), nil&#125; 2. 利用goroutine实现并发GO语言的goroutine是实现并发的核心工具。它比线程更轻量，启动速度快，适合处理高并发任务。 123456789101112func printNumbers() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125;&#125;func main() &#123; go printNumbers() // 启动一个goroutine go printNumbers() // 启动另一个goroutine time.Sleep(3 * time.Second) // 等待goroutine执行完毕&#125; 3. 使用channel进行通信channel是GO语言中用于goroutine之间通信的工具。它可以安全地传递数据，避免竞态条件。 123456789101112131415161718192021222324func worker(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for job := range jobs &#123; fmt.Printf(&quot;Worker %d processing job %d &quot;, id, job) results &lt;- job * 2 &#125;&#125;func main() &#123; jobs := make(chan int, 10) results := make(chan int, 10) for w := 1; w &lt;= 3; w++ &#123; go worker(w, jobs, results) &#125; for j := 1; j &lt;= 5; j++ &#123; jobs &lt;- j &#125; close(jobs) for a := 1; a &lt;= 5; a++ &#123; fmt.Println(&quot;Result:&quot;, &lt;-results) &#125;&#125; 4. 使用sync.WaitGroup等待多个goroutine完成sync.WaitGroup用于等待一组goroutine完成任务，非常适合需要同步的场景。 12345678910111213141516func worker(id int, wg *sync.WaitGroup) &#123; defer wg.Done() // 任务完成后通知WaitGroup fmt.Printf(&quot;Worker %d starting &quot;, id) time.Sleep(time.Second) fmt.Printf(&quot;Worker %d done &quot;, id)&#125;func main() &#123; var wg sync.WaitGroup for i := 1; i &lt;= 3; i++ &#123; wg.Add(1) // 增加WaitGroup的计数器 go worker(i, &amp;wg) &#125; wg.Wait() // 等待所有goroutine完成 fmt.Println(&quot;All workers done&quot;)&#125; 5. 使用interface实现多态GO语言通过interface实现多态，允许不同类型的对象实现相同的接口。 1234567891011121314151617181920type Animal interface &#123; Speak() string&#125;type Dog struct&#123;&#125;func (d Dog) Speak() string &#123; return &quot;Woof!&quot;&#125;type Cat struct&#123;&#125;func (c Cat) Speak() string &#123; return &quot;Meow!&quot;&#125;func main() &#123; animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125; for _, animal := range animals &#123; fmt.Println(animal.Speak()) &#125;&#125; 6. 使用context管理goroutine生命周期context用于控制goroutine的生命周期，特别是在需要取消任务或设置超时的场景中非常有用。 1234567891011121314151617181920212223func worker(ctx context.Context, wg *sync.WaitGroup) &#123; defer wg.Done() for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;Worker canceled&quot;) return default: fmt.Println(&quot;Working...&quot;) time.Sleep(500 * time.Millisecond) &#125; &#125;&#125;func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() var wg sync.WaitGroup wg.Add(1) go worker(ctx, &amp;wg) wg.Wait()&#125; 7. 使用struct标签实现JSON序列化GO语言支持通过struct标签将结构体字段映射为JSON字段，方便数据的序列化和反序列化。 12345678910type User struct &#123; Name string `json:&quot;name&quot;` Email string `json:&quot;email&quot;`&#125;func main() &#123; user := User&#123;Name: &quot;Alice&quot;, Email: &quot;alice@example.com&quot;&#125; jsonData, _ := json.Marshal(user) fmt.Println(string(jsonData)) // 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;email&quot;:&quot;alice@example.com&quot;&#125;&#125; 8. 使用errors包创建自定义错误GO语言的errors包允许创建自定义错误，便于错误处理和调试。 1234567891011121314151617import &quot;errors&quot;func divide(a, b int) (int, error) &#123; if b == 0 &#123; return 0, errors.New(&quot;division by zero&quot;) &#125; return a / b, nil&#125;func main() &#123; result, err := divide(10, 0) if err != nil &#123; fmt.Println(&quot;Error:&quot;, err) &#125; else &#123; fmt.Println(&quot;Result:&quot;, result) &#125;&#125; 9. 使用go mod管理依赖go mod是GO语言的官方依赖管理工具，可以轻松管理项目的依赖关系。 12345678# 初始化模块go mod init myproject# 添加依赖go get github.com/example/package# 清理未使用的依赖go mod tidy 10. 使用testing包编写单元测试GO语言内置了testing包，支持编写单元测试，确保代码质量。 123456789101112import &quot;testing&quot;func Add(a, b int) int &#123; return a + b&#125;func TestAdd(t *testing.T) &#123; result := Add(2, 3) if result != 5 &#123; t.Errorf(&quot;Expected 5, got %d&quot;, result) &#125;&#125; 运行测试： 1go test 以上是GO语言中最有价值的十个技巧，涵盖了资源管理、并发编程、错误处理等多个方面。希望这些技巧能帮助你写出更高效、更健壮的GO代码！如果你有其他问题，欢迎在评论区留言讨论。"},{"path":"/2025/02/08/tts/","content":"1. 安装ttshttps://github.com/idiap/coqui-ai-TTS"},{"path":"/2025/02/06/自我介绍/","content":"自我介绍 ✨我是 董洪伟，一名来自 北京 的 软件工程师。我热爱编程和技术分享，专注于 Web 开发 和 人工智能 领域。 @keyframes glow { 0% { text-shadow: 0 0 5px #33FF57, 0 0 10px #33FF57; } 100% { text-shadow: 0 0 20px #33FF57, 0 0 30px #33FF57; } } 🚀 我的经历 教育背景：毕业于 南京理工大学，主修 智能科学与技术。 工作经历：目前在 百度 担任担任资深开发工程师。 技术栈：熟练掌握 Golang、Python。 🌟 我的兴趣 喜欢研究 前沿技术，尤其是 AIGC 和 工程架构。 业余时间会写一些技术博客，分享我的学习和实践经验。 热爱 阅读年均阅读量 50+。 📬 联系我如果你对我的博客内容感兴趣，或者有任何问题，欢迎通过以下方式联系我： 邮箱：derekdongsir@163.com GitHub: https://github.com/DerekDongSir 个人网站：https://blog.derekdong.com/ 感谢你的阅读，期待与你交流！🎉"},{"path":"/2025/01/26/评论系统/","content":"https://zhuanlan.zhihu.com/p/691921194https://giscus.app/zh-CN"},{"title":"Sug","path":"/2025/01/26/sug/","content":"生产环境的sug功能如何实现"},{"title":"Hello World","path":"/2025/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.addEventListener('DOMContentLoaded', function() { const heatmapChartDom = document.getElementById('heatmapChart-0'); if (heatmapChartDom) { const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; const backgroundColor = isDarkMode ? '#333' : 'transparent'; let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light'); const cellSize = [16, 16]; const groupedData = {\"2025\":[[\"2025-01-26\",3]]}; const years = Object.keys(groupedData).reverse(); const initYear = '2025' || years[0]; // Define color themes const themes = { oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'], forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'], sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'], earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'], pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'], golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'], berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'], charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'], }; // Function to get a random theme function getRandomTheme() { const themeKeys = Object.keys(themes); const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)]; return themes[randomKey]; } // Use the specified theme or default to 'random' const colors = themes['random'.toLowerCase()] || getRandomTheme(); const chartOptions = { backgroundColor: backgroundColor, tooltip: { position: 'top', confine: true, formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`, }, calendar: { top: '13%', left: '2%', right: '8%', range: initYear, cellSize: cellSize, splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor }, dayLabel: { show: false }, monthLabel: { show: true }, yearLabel: { show: false }, }, visualMap: { show: true, right: '8%', bottom: '5%', type: 'piecewise', orient: 'horizontal', text: ['More', 'Less'], min: 0, max: Math.max(...groupedData[initYear].map(item => item[1])), inRange: { color: colors }, }, legend: { type: 'scroll', icon: 'none', data: years, orient: 'vertical', top: '5%', right: 'right', itemWidth: 20, itemHeight: 20, itemGap: 10, pageIconSize: 10, pageTextStyle: { fontSize: 14 }, selectedMode: 'single', }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== initYear, })), }; heatmapChart.setOption(chartOptions); heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Function to handle legend selection changes const handleLegendSelectChanged = function(params) { const selectedYear = Object.keys(params.selected).find(key => params.selected[key]); if (selectedYear && groupedData[selectedYear]) { heatmapChart.setOption({ calendar: { range: selectedYear }, visualMap: { max: Math.max(...groupedData[selectedYear].map(item => item[1])), }, series: years.map(year => ({ type: 'heatmap', coordinateSystem: 'calendar', data: groupedData[year], name: year, emphasis: { disabled: true }, silent: year !== selectedYear, })), }); } }; const handleClick = function(params) { if (params.componentType === 'series') { const [year, month] = params.value[0].split('-'); window.location.href = '/archives/' + year + '/' + month; } }; heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); // Listen for theme changes window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => { heatmapChart.dispose(); heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light'); const newBackgroundColor = event.matches ? '#333' : 'transparent'; chartOptions.backgroundColor = newBackgroundColor; chartOptions.calendar.itemStyle.color = newBackgroundColor; heatmapChart.setOption(chartOptions); // Re-select the initial year heatmapChart.dispatchAction({ type: 'legendSelect', name: initYear, }); // Reattach the event listeners heatmapChart.on('legendselectchanged', handleLegendSelectChanged); heatmapChart.on('click', handleClick); }); } }); Powered by hexo-stats-echarts"},{"path":"/prompt.html","content":"你是一名GO技术专家，擅长使用GO语言，同时，你是一名技术博主，擅长将技术知识以通俗易懂的方式进行讲解。 现在，你正在写一篇关于GO语言的文章，文章的标题是：《GO语言最有价值的十个技巧》。 请根据以下要求，撰写一篇关于GO语言编程的文章： 文章需要包含10个GO语言的技巧。 文章需要使用通俗易懂的语言，让读者容易理解。 文章需要包含代码示例，让读者可以实际操作。 文章以markdown格式编写，并使用代码高亮。"}]